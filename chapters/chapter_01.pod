=head1 1: OO introduced

If you're familiar with the basics of OO, from experience with other languages, you may want to skip 
portions of this chapter. However, I'd recommend at least skimming it to be sure that you're familiar 
with the terms I'll be using for certain aspects of OO programming (e.g. 'attributes' vs 'properties').

=head2 Procedural programming

If you've not had any experience with OO programming, it's very likely that what you've been doing, 
consciously or not, is procedural programming. In procedural languages, such as Perl (prior to Perl 
5), PHP (prior to PHP 4), Visual Basic and the like, code flows from statement to statement in a 'do 
this, then this' kind of way. It's possible to define complex datatypes to represent real-world or 
virtual things, but these are simply dumb collections of attributes with no knowledge of what behaviour 
the thing it represents has. Equally, it's possible to define subroutines to re-use common code, but 
again the subroutines bear no formal relationship to the things the program is dealing with.

For example, we could defineN<All code examples in this chapter will be in something that looks 
rather like Perl but without paying too much attention to syntactic rigour.> a structure that represents a person:

    $person = { name => "Mike", legs => 2 };
  
We can then define a subroutine C<go_for_walk>:

    sub go_for_walk {
        my $thing = shift;
        
        say $thing->{name} . " walks on " . $thing->{legs} . " legs."
    }

That's Perl 5.10's C<say> function, because I so hate having to add "\n" at the end of every C<print>. 
Let's go for a walk:

    go_for_walk($person);
    > Mike walks on 2 legs.
    
Now we can define a data structure to represent man's best friend:

    $dog = { name => "Spot", legs => 4 };
  
Spot! Here boy! Walkies!

    go_for_walk($dog);
    > Spot walks on 4 legs.
    
Good dog! Flushed as we are with our (and Spot's) success, let's declare another subroutine that 
allows a person to give a greeting:

  sub give_greeting {
      my $person = shift;
      
      say $person->{name} . ' says "Hello."';
  }
  
  give_greeting($person);
  > Mike says "Hello."
  
Great. Except that our C<give_greeting> subroutine has no clue about what kind of thing its argument 
is, so when we call:

    give_greeting($dog);
    
we get

    > Spot says "Hello."
    
And suddenly, we have the punchline to one of my favourite jokes.N< There are these two racehorses in a bar. 
One says to the other: "Had a strange day. There I was, dead last in the 3.15 at Epsom, and suddenly, something 
stings me in my rump, whoosh, I started running really fast, finished first by a length."
The second horse says "That's strange. The exact same thing happened to me in the 2.40 at Newmarket."
A greyhound down the other end of the bar pipes up, "You know, the same thing happened to me in the 7.56 at Harringay last night."
First horse looks in shock at second horse. "Blimey! A talking dog!"> 
More importantly, the C<give_greeting> subroutine has allowed a C<Dog> to perform a behaviour (delivering a 
greeting) that it shouldn't be able to do.

That's not so good. We can, though, code round it. Let's add a property C<type> to both our data 
structures, and define another subroutine:

    $person = { name => "Mike", legs => 2,, type => "Person" };
    $dog = { name => "Spot", legs => 4, type => "Dog"};

    sub be_happy {
        my $thing = shift;
        
        if ($thing->{type} eq 'Dog') {
            say $thing->{name} . " wags its tail.";
        }
        else {
            say $thing->{name} . " smiles."
        }
    }
    
Cool. Now we have a C<be_happy> subroutine that can handle things of type C<Person> and type C<Dog>. 

Except... suppose we add another type of thing, C<Cat>. We've suddenly got two problems (not to mention 
talking cats!). 

    $cat = { name => "Tiddles", legs => 4, type => "Cat" };
    be_happy($cat);
    > Tiddles smiles.

Not only do we not handle the concept of cats in C<be_happy>, our sloppy coding (the catch-all C<else> construct) means that they actually behave like people!

So, how do we fix this?

Obviously, we could just plough on writing ever more complex conditionals in each of our subroutines, but 
that comes with a greater and greater attendant risk of, to be blunt, screwing it up. Every time we add a 
new datatype, we have to fix every new action subroutine that might be called with it, and conversely, 
every time we add a new action subroutine, we have to make sure we handle every type of thing that might 
be passed to it.

Not pretty. But not to worry...

=head2 Moving towards OO

Let's have another crack at C<be_happy()>, but this time let's make calling the per-thing subroutines a little less error-prone.

    sub be_happy {
        my $thing = shift;
        
        my $dispatch_table = {
            Cat    => \&be_happy_cat,
            Dog    => \&be_happy_dog,
            Person => \&be_happy_person,
        }
        
        my $be_happy_sub = $dispatch_table->{ $thing->{type} };
        $be_happy_sub->($thing);
    }
    
    sub be_happy_cat {
        my $cat = shift;
        say $cat->{name} . " purrs."
    }
    
    # etc etc
    
Now all we have to do is add a row to the dispatch table for every new object. That's a lot less pain. 
But... wait. In fact, we can do better yet. Because Perl allows us to define anonymous subroutines
N<If this is starting to make your head spin, I suggest a trip back to the 'Modern Perl' book, 
specifically chapter 5's section on anonymous functions.>, 
we could actually store the C<be_happy_cat> code on the cat, like this:

    sub be_happy {
        my $thing = shift;
        return $thing->{be_happy_sub}->{$thing};
    }
    
    $cat = { 
        name => "Tiddles the nearly object-oriented cat",
        legs => 4,
        be_happy_sub => sub { 
            my $self = shift;
            say $self->{name} . " purrs.";
        }
    }
    
    # etc etc
    
Now C<be_happy()> doesn't have to care what type $thing is at all. Better yet, in fact, C<be_happy> doesn't
really need to exist, because we can go:
    
    $thing->{be_happy_sub}->{$thing};
    
and get the desired result, whatever $thing is, provided it has a C<be_happy_sub>. What we've actually 
done here, in fact, is to move the knowledge of how a cat performs C<be_happy> onto the cat itself.

Well, almost. If we create another cat, we do actually have to duplicate all that common-to-every-cat 
code on the new cat, which gets to be a faff after a while. But we can work round that, as well. And 
here's where we start to introduce some OO terminology.

=head3 Classes, Objects, Instances, Attributes and Methods

Tiddles the nearly object-oriented cat, and all other cats, belong to the B<class> "Cat": their behaviours 
are defined because they are C<Cat>s. In OO terms, we say they are B<objects> which are B<instances> of 
the class C<Cat>.

With that in mind, let's actually I<define> a class C<Cat>:

    $Cat = {
        type => "Cat";
        # ...     
    };

    $tiddles = {
        name = "Tiddles the even more nearly OO cat",
        _class => $Cat,
    }
    
In OO parlance, the C<name> field on C<$tiddles> is called a property or an B<attribute>. We (which is 
to say Moose) will use the latter term.

As it stands, that doesn't seem to gain us much. But now we can move the definitions of all the cat-like
behaviours on to the I<class>, rather than the individual I<instance>. In OO parlance, these behaviours are
called B<methods>. So let's go ahead and expand the definition of C<Cat> a bit. In essence, what we're going
to do is reinstate our dispatch table, but instead of using it to pick the right method for a given
object, we're going to use it to pick from between the methods available to an object.

    $Cat = {
        type => "Cat";
        _methods => {
            be_happy => sub {
                my $self = shift;
                say $self->{name} . " purrs."
            },
        }     
    };

This may seem a bit convoluted, but now we can say:

    $tiddles->{_class}->{_methods}->{be_happy}->{$tiddles};
    > Tiddles the even more nearly OO cat purrs.

We can now add or modify methods on C<Cat> as we choose, and all objects that are instances of the 
class will pick them up. Fantastic. Let's add another method, C<new()>:

    $Cat = {
        type => "Cat";
        _methods => {
            be_happy => sub {
                my $self = shift;
                say $self->{name} . " purrs."
            },
            new => sub {
                return { _class => $Cat, @_ };
            },
        }     
    };

What's special about C<new>? It's what's known in OO circles as a B<constructor> method - it allows us 
to create a new I<instance> of a I<class>, like this:

    $tom = $Cat->{_methods}->{new}->( name => "Thomas O'Malley" );
    
    $tom->{_class}->{_methods}->{be_happy}->{$tom};
    > Thomas O'Malley purrs.
    
=head3 Introspection

On top of that, we can now ask an object about itself. This is called B<introspection>. For example, we 
can find out what class it is...

    sub isa {
        my $object = shift;
        my $class = shift;
        return ($object->{_class}->{_type} eq $class);
    }
    print isa($tom, 'Cat') ? "yes" : "no";
    > yes

... or whether it's capable of a certain behaviour...

    sub can {
        my $object = shift;
        my $method = shift;
        
        return exists $object->{_class}->{_methods}->{$method};
    }
    print can($tom, 'bark') ? "yes" : "no";
    > no
    
Hopefully, you're starting to get the idea. However, this approach to OO still isn't perfect. Among 
other things, the syntax is clunky, and the methods on our classes are all anonymous subroutines, 
which is going to make things like debugging hard. 
    
=head2 Doing it properly.

We've basically done all the above as if our Perl-like language had no OO features at all. 

=cut