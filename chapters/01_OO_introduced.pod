=head1 1: OO introduced

If you're familiar with the basics of OO, from experience with other languages, you may want to skip portions of this chapter. However, I'd recommend at least skimming it to be sure that you're familiar with the terms I'll be using for certain aspects of OO programming (e.g. 'attributes' vs 'properties').

=head2 Procedural programming

If you've not had any experience with OO programming, it's very likely that what you've been doing, consciously or not, is procedural programming. In procedural languages, such as Perl (prior to Perl 5), PHP (prior to PHP 4), Visual Basic and the like, code flows from statement to statement in a 'do this, then this' kind of way. It's possible to define complex datatypes to represent real-world or virtual things, but these are simply dumb collections of attributes with no knowledge of what behaviour the thing it represents has. Equally, it's possible to define subroutines to re-use common code, but again the subroutines bear no formal relationship to the things the program is dealing with.

For example, we could defineN<All code examples in this chapter will be in something that looks rather like Perl but without all the syntactic rigour.> a structure that represents a person:

    $person = { name => "Mike", legs => 2 };
  
We can then define a subroutine C<go_for_walk>:

    sub go_for_walk {
        my $thing = shift;
        
        say $thing->{name} . " walks on " . $thing->{legs} . " legs."
    }

That's Perl 5.10's C<say> function, because I so hate having to add "\n" at the end of every C<print>. Lets go for a walk:

    go_for_walk($person);
    > Mike walks on 2 legs.
    
Now we can define a data structure to represent man's best friend:

    $dog = { name => "Spot", legs => 4 };
  
Spot! Here boy! Walkies!

    go_for_walk($dog);
    > Spot walks on 4 legs.
    
Good dog! Flushed as we are with our (and Spot's) success, let's declare another subroutine that allows a person to give a greeting:

  sub give_greeting {
      my $person = shift;
      
      say $person->{name} . ' says "Hello."';
  }
  
  give_greeting($person);
  > Mike says "Hello."
  
Great. Except that our C<give_greeting> subroutine has no clue about what kind of thing its argument 
]is, so when we call:

    give_greeting($dog);
    
we get

    > Spot says "Hello."
    
And suddenly, we have the punchline to one of my favourite jokes.N< There are these two racehorses in a bar. 
One says to the other: "Had a strange day. There I was, dead last in the 3.15 at Epsom, and suddenly, something 
stings me in my rump, whoosh, I started running really fast, finished first by a length."
The second horse says "That's strange. The exact same thing happened to me in the 2.40 at Newmarket."
A greyhound down the other end of the bar pipes up, "You know, the same thing happened to me in the 7.56 at Harringay last night."
First horse looks in shock at second horse. "Blimey! A talking dog!"> 
More importantly, the C<give_greeting> subroutine has allowed a C<Dog> to perform a behaviour (delivering a 
greeting) that it shouldn't be able to do.

That's not so good. We can, though, code round it. Let's add a property C<type> to both our data 
structures, and define another subroutine:

    $person = { name => "Mike", legs => 2,, type => "Person" };
    $dog = { name => "Spot", legs => 4, type => "Dog"};

    sub be_happy {
        my $thing = shift;
        
        if ($thing->{type} eq 'Dog') {
            say $thing->{name} . " wags its tail.";
        }
        else {
            say $thing->{name} . " smiles."
        }
    }
    
Cool. Now we have a C<be_happy> subroutine that can handle things of type C<Person> and type C<Dog>. 

Except... suppose we add another type of thing, C<Cat>. We've suddenly got two problems (not to mention 
talking cats!). 

    $cat = { name => "Tiddles", legs => 4, type => "Cat" };
    be_happy($cat);
    > Tiddles smiles.

Not only do we not handle the concept of cats in C<be_happy>, our sloppy coding (the catch-all C<else> construct) means that they actually behave like people!

So, how do we fix this?

Obviously, we could just plough on writing ever more complex conditionals in each of our subroutines, but 
that comes with a greater and greater attendant risk of, to be blunt, screwing it up. Every time we add a 
new datatype, we have to fix every new action subroutine that might be called with it, and conversely, 
every time we add a new action subroutine, we have to make sure we handle every type of thing that might 
be passed to it.

Not pretty. But not to worry, because here comes our saviour...

=head2 Object Oriented Programming

Let's have another crack at C<be_happy()>, but this time let's make calling the per-thing subroutines a little less error-prone.

    sub be_happy {
        my $thing = shift;
        
        my $dispatch_table = {
            cat    => \&be_happy_cat,
            dog    => \&be_happy_dog,
            person => \&be_happy_person,
        }
        
        my $be_happy_sub = $dispatch_table->{ $thing->{type} };
        $be_happy_sub->($thing);
    }
    
    sub be_happy_cat {
        my $cat = shift;
        say $cat->{name} . " purrs."
    }
    
    # etc etc
    
Now all we have to do is add a row to the despatch table for every new object. That's a lot less pain. But.. wait. In fact, we can do better yet. Because Perl allows us to define anonymous subroutinesN<If this is starting to make your head spin, I suggest a trip back to the 'Modern Perl' book, specifically chapter 5's section on anonymous functions.>, we could actually store the C<be_happy_cat> code on the cat, like this:

    sub be_happy {
        my $thing = shift;
        return $thing->{be_happy_sub}->{$thing};
    }
    
    my $cat = { 
        name => "Nearly OO Tiddles",
        legs => 4,
        be_happy_sub => sub { 
            my $self = shift;
            say $self->{name} . " purrs.";
        }
    }
    
    # etc etc
    
Now C<be_happy()> doesn't have to care what type $thing is at all. Better yet, in fact, C<be_happy> doesn't
really need to exist, because we can go:
    
    $thing->{be_happy_sub}->{$thing};
    
and get the desired result, whatever $thing is, provided it has a C<be_happy_sub>. What we've actually done 
here, in fact, is to move the knowledge of how a cat performs C<be_happy> onto the cat itself. 

=cut